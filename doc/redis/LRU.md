## 使用Redis作为一个LRU缓存

当redis作为一个缓存时，当你需要添加新数据时自动地移除旧数据，是非常方便的一件事情。
这是所有开发者都熟知的一点，因为另一个受欢迎的缓存系统mencached的默认行为。

  LRU实际上只是回收策略中的一种。本页包含的内容一般主题，像介绍用redis中的maxmemory指令来限制
可用内存到一个合适的大小，也深入介绍了Redis使用的LRU算法---实际上是一种近似的LRU  
从Redis 4.0版本开始，引入了一个新的LFU(最不常用的)回收策略。这将在本文档的单独部分中讨论。


### Maxmemory配置指令
  maxmemory配置指令用于配置Redis来为数据集使用指定数量的内存。可以使用Redis .conf文件来设置配置指令，或者稍后在运行时使用CONFIG set命令。
例如，为了配置100 mb的内存限制，可以在redis.conf文件中使用以下指令。
- maxmemory 100mb

将maxmemory设置为0将导致没有内存限制。这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。
当达到指定的内存量时，可以在不同的行为(称为策略)之间进行选择。
Redis可以在调用可能导致更多内存被使用的命令时抛出错误，
或者它可以删除一些旧数据，以便在每次添加新数据时回到指定的限制之内。


### 回收策略
当达到最大内存限制时，使用maxmemory-policy配置指令配置Redis的确切行为。
以下是所有可用的策略：
* noeviction(不回收):当客户端尝试运行会增加使用内存的指令时抛出错误（大多数write指令，除了
* DEL 和其他）
* allkey-lru:尝试删除最近最少使用的keys
* volatile-lru:尝试删除最近最少使用的keys，但仅限于那些有设置了expire的key(过期时间)
* allkeys-random:随机回收
* volatile-random:在设置了expire的keys中随机回收
* volatile-ttl:对设定了过期时间，但是time to live 时间较短的key进行回收

volatile-lru, volatile-random and volatile-ttl 策略如果所有key都没有设置过期时间，
那么将表现得和noeviction一样。
根据你的应用程序的访问模式来选择最合适的回收策略是很必要的，但是你可以在程序运行时重新选择策略，
然后通过Redis INFO指令的数据观察缓存命中和不命中的数量 来调优你的设置。

总的来说，作为一个经验法则：
  allkeys-lru:当你的请求的keys的频率符合幂率分布（例如80%的请求在20%的key上）,也就是说，被访问的一部分
  元素的频率远比其他元素大。或者，当你啥都不确定时，这是个好策略。
  allkey-random: 当你会循环扫描所有keys时，会持续轮询所有的键。或者预期的请求符合均匀分布
  volatile-ttl : 你希望你能给redis一些提示，即哪些是可抛弃的优秀优选人，通过设定不同的TTL值。

  volatile-lru和volatile-random策略在希望使用单个实例进行缓存和拥有一组持久键时非常有用。
然而，运行两个Redis实例来解决这样的问题通常是一个更好的主意。
> 值得注意的是，为key设置expire将会消耗内存，因此使用allkeys-lru这样的策略会提高内存利用率，
因为在内存压力下不需要设置expire来清除键值。

### 回收过程是如何工作的：
理解一下的回收过程很重要：
1. 某个客户端发起新指令，造成更多的数据被添加。
2. Redis检查内存使用量，如果比maxmemory limit更大,开始根据回收策略来回收keys
3. 新指令执行，循环继续。

所以我们不断地超过内存限制，超过，然后回退到边界内。
如果一个命令造成大量内存被使用(比如一个大集合的交集存储到一个新键中)，可能会明显超过内存limit。

近似的LRU算法
Redis算法不是一个直接的实现，这一位置Redis没办法选出一个最合适的回收对象，也没办法确认过去访问最多的对象。
相反地，它会尝试运行一个人近似的LRU算法，通过抽取一小数量的keys，然后回收这里面最合适的key。

然而自从Redis3.0以来该算法得到了改进，使用一个对象池来盛装回收对象候选人。这些提升使得近似更接近真实的LRU算法。
RedisLRU算法重要的一点是你可以通过调整算法的精度，通过改变抽样的数量。以下命令
maxmemory-samples 5
Redis不使用真实LRU的原因是这会花费更多的内存。然而对于使用redis的应用来说几乎是近似的。以下是
使用真实LRU和redis LRU的图像对比

生成上述图形的测试用给定数量的键填充了一个Redis服务器。从第一个键到最后一个键进行存储，
因此第一个键是使用LRU算法进行清除的最佳候选键。
稍后将添加更多的50%的密钥，以便强制驱逐一半的旧密钥。
在一个理论上的LRU实现中，我们预计在旧的密钥中，前一半将过期。Redis LRU算法只会在概率上使旧密钥过期。
你可以看到，与Redis 2.8相比，Redis 3.0在5个样本中表现得更好，但是最新访问的大多数对象仍然被Redis 2.8保留。在Redis 3.0中使用10的样本量，这个近似值非常接近于Redis 3.0的理论性能。
请注意，LRU只是一个模型，用于预测将来访问给定密钥的可能性。此外，如果你的数据交流




















