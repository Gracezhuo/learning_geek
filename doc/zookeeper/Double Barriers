双重栅栏
双重栅栏能同步客户端们计算的开始和结束。当足够的处理线程到达栅栏，处理线程开始他们的计算，然后当他们完成时离开栅栏。
这个清单展示了如何使用Zookeeper节点作为栅栏

每个客户端进程P注册到栅栏节点上，然后准备离开时注销。一个节点通过Enter里的操作来注册到栅栏上，
它会登待知道X个客户处理线程注册后才开始计算。这个X取决去你自己的系统设定。
b=栅栏节点
p=客户端进程
n=子节点
x=开启数目
Enter
1 创建一个名称 n = b+"/"+p
2 设置监控 exists(b + "/ready",true)
3 创建子节点 create(n,EPHEMERAL)//临时节点，客户端退出后自动消失
4 L=getChildren(b,false)
5 如果L(子节点)的数量小于x ，继续登待监控事件
6 否则 create(b+"/ready",REGULAR) //常规节点

Leave
1 L=getChildren(b,false)
2 如果没有子节点 退出
3 如果当前p是L里唯一的节点，删除delete(n) 然后退出
4 如果当前p是L里最小节点，监视L里的最高的节点
5 否则delete(n),如果L里面还有节点，那么监视最小的
6 goto 1

进入时，所有进程监视ready节点然后在barrier节点下创建临时子节点。除了最后一个进入的线程，每个线程
进入栅栏并登待ready节点的出现。当创建第x个节点的线程，也就是最后一个进程，会看到x个节点在L里
并创建ready节点，并因此换姓了其他的进程。注意等待进程只有在时间到时才会被唤醒，所以
等待的操作是高效的。

退出时，你并没有看到类似ready的标志物，因为你是在监视要离开的线程。通过使用临时节点。
进程，通过栅栏又失败了的进程不会影响程序的正确执行。
当线程准备离开时，他们需要删除他们自身的节点，并等待其他进程也删除。
当b下面没有流程子节点时，进程将会退出。然而，为了效率起见，你可以把最小处理器当作ready标志。
其他所有进程监视存在的最小的节点离开吗，然后最小节点本身监视其他节点(简化，使用最高节点)离开。
着这意味着除了最后一个节点,每个节点删除时只有一个线程唤醒（这里搞不懂），当最后一个节点()被唤醒时，所有节点就都已经被删除了。

