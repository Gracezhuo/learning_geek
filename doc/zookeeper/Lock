锁

全局同步的完全分布式锁，意味着在任何快照时间点上，没有两个客户端会同时获取到同一把锁。
这可以使用ZK来实现。类似优先级队列，首先需要定义一个lock node。

客户端通过以下操作来获得锁：
1 调用create（pathname:"locknode/guid-lock-",顺序性，临时性），guid是当create的结果丢失时需要的(通常是由于连接的不稳定性)，
详见下面的提示。
2 在lock node上调用getChildren(),无需设置监视(这很重要，可以避免羊群效应)
3 如果步骤1 创建的节点路径有最小的后缀，那么当前客户端可以获得锁然后退出协议。
4 客户端调用exists()并设置监控在比当前创建节点小的节点上。
5 如果exists返回空，跳到步骤2.否则，在转到步骤2之前，等待前一步的路径名通知。

释放锁的协议非常简单：当客户端想要释放锁，那么它只要删除它们在步骤1中创建的节点。

这里有几个事情需要注意：
1 删除一个节点只会导致一个客户机唤醒，因为每个节点都由一个客户机监视。这样，你就避免了羊群效应。
2 没有使用到任何轮询和超时。
3 由于实现锁定的方式，你很容易观察到锁争用的数量、解锁、调试锁定问题等


可恢复的错误和GUID(Globally Unique Identifier全局唯一标识)
如果create调用时发生了可恢复的错误，客户端应该调用getChildren(),然后检查是否有node使用这个guid作为path。
这是为了应对某些情况下，create()已经在服务端中成功创建，但是在返回新节点名称之前挂掉了。

共享锁
你可以通过几个修改来实现共享锁:
获取读锁：
1调用create()来创建节点 "guid-/read-"。这是稍后要使用的lock node。需要开启sequence和ephemeral属性。
2在lock node 上调用getChildren()，无需监视，这很重要，可以避免羊群效应。
3如果没有以write开头且序列号比步骤1创建的节点更低的节点，那么该客户端获取到锁并退出过程。
4否则，在以“write—”开头的，更小一些的节点上调用exists()并设置监控。
5如果exist（）返回false ，则跳到步骤2 .
6否则等待上一步的监控回调通知，然后再跳到步骤2

获取写锁：
1 调用create(）创建节点"guid-/write-"，这是稍后在协议中提到的锁节点。确保同时设置序列和临时标记。
2 调用getChidren()，无需监控
3 如果没有比步骤1 创建的节点序列号小的，那么客户端获取到锁并退出过程。
4 在小一些的节点上调用exist(),并监控
5 如果exist()返回false，跳转到步骤2。否则等待通知，再返回步骤2.

//这个方法可能会产生一种羊群效应:
当有大量的客户端等待读锁时，当删除序列号最低的“写”节点时，所有的客户端或多或少都会同时得到通知。
事实上。这是有效的行为:因为所有等待的读取器客户机都应该被释放，因为它们都有锁。
“羊群效应”指的是当实际上只有一个或一小部分机器可以进行操作时，释放一个“羊群”。


只需对共享锁协议进行少量修改，就可以通过修改共享锁协议来实现共享锁的可撤销性:
在步骤1中，获取读写锁协议，使用watch set调用getData()，紧接着调用create()。
如果客户机随后收到它在步骤1中创建的节点的通知，它将在该节点上执行另一个getData()操作，并设置监视，
并查找字符串“unlock”，它将向客户机发出必须释放锁的信号。
这是因为，根据这个共享锁协议，您可以通过调用锁节点上的setData()，
向该节点写入“unlock”来请求拥有锁的客户机放弃锁。
注意，此协议要求锁持有者同意释放锁。这种同意是重要的，特别是如果锁持有人需要做一些处理之前释放锁。
当然，通过在协议中规定，如果经过一段时间后锁未被锁持有者删除，则撤销者可以删除锁节点，您总是可以用异常的激光束实现可撤销的共享锁。